/**
 * Generated by orval v7.8.0 ðŸº
 * Do not edit manually.
 * Game Portal API
 * OpenAPI spec version: 1.0.0
 */
import useSwr from 'swr';
import type {
  Arguments,
  Key,
  SWRConfiguration
} from 'swr';

import useSWRMutation from 'swr/mutation';
import type {
  SWRMutationConfiguration
} from 'swr/mutation';

import type {
  FriendRequests,
  Friends,
  GameResults,
  GameState,
  Games,
  Leaderboards,
  SessionInvites,
  SessionPlayers,
  Sessions,
  Users
} from '../models';



  
  
  
/**
 * @summary Get list of users
 */
export type getUsersResponse200 = {
  data: Users[]
  status: 200
}
    
export type getUsersResponseComposite = getUsersResponse200;
    
export type getUsersResponse = getUsersResponseComposite & {
  headers: Headers;
}

export const getGetUsersUrl = () => {


  

  return `/users`
}

export const getUsers = async ( options?: RequestInit): Promise<getUsersResponse> => {
  
  const res = await fetch(getGetUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getUsersResponse
}




export const getGetUsersKey = () => [`/users`] as const;

export type GetUsersQueryResult = NonNullable<Awaited<ReturnType<typeof getUsers>>>
export type GetUsersQueryError = Promise<unknown>

/**
 * @summary Get list of users
 */
export const useGetUsers = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getUsers>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetUsersKey() : null);
  const swrFn = () => getUsers(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new users
 */
export type createUsersResponse201 = {
  data: void
  status: 201
}
    
export type createUsersResponseComposite = createUsersResponse201;
    
export type createUsersResponse = createUsersResponseComposite & {
  headers: Headers;
}

export const getCreateUsersUrl = () => {


  

  return `/users`
}

export const createUsers = async (users: Users, options?: RequestInit): Promise<createUsersResponse> => {
  
  const res = await fetch(getCreateUsersUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      users,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createUsersResponse
}




export const getCreateUsersMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Users }): Promise<createUsersResponse> => {
    return createUsers(arg, options);
  }
}
export const getCreateUsersMutationKey = () => [`/users`] as const;

export type CreateUsersMutationResult = NonNullable<Awaited<ReturnType<typeof createUsers>>>
export type CreateUsersMutationError = Promise<unknown>

/**
 * @summary Create a new users
 */
export const useCreateUsers = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createUsers>>, TError, Key, Users, Awaited<ReturnType<typeof createUsers>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateUsersMutationKey();
  const swrFn = getCreateUsersMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific users
 */
export type getUsersByIdResponse200 = {
  data: Users
  status: 200
}
    
export type getUsersByIdResponseComposite = getUsersByIdResponse200;
    
export type getUsersByIdResponse = getUsersByIdResponseComposite & {
  headers: Headers;
}

export const getGetUsersByIdUrl = (userId: string,) => {


  

  return `/users/${userId}`
}

export const getUsersById = async (userId: string, options?: RequestInit): Promise<getUsersByIdResponse> => {
  
  const res = await fetch(getGetUsersByIdUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getUsersByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getUsersByIdResponse
}




export const getGetUsersByIdKey = (userId: string,) => [`/users/${userId}`] as const;

export type GetUsersByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getUsersById>>>
export type GetUsersByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific users
 */
export const useGetUsersById = <TError = Promise<unknown>>(
  userId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getUsersById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(userId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetUsersByIdKey(userId) : null);
  const swrFn = () => getUsersById(userId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific users
 */
export type updateUsersResponse200 = {
  data: void
  status: 200
}
    
export type updateUsersResponseComposite = updateUsersResponse200;
    
export type updateUsersResponse = updateUsersResponseComposite & {
  headers: Headers;
}

export const getUpdateUsersUrl = (userId: string,) => {


  

  return `/users/${userId}`
}

export const updateUsers = async (userId: string,
    users: Users, options?: RequestInit): Promise<updateUsersResponse> => {
  
  const res = await fetch(getUpdateUsersUrl(userId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      users,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateUsersResponse
}




export const getUpdateUsersMutationFetcher = (userId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Users }): Promise<updateUsersResponse> => {
    return updateUsers(userId, arg, options);
  }
}
export const getUpdateUsersMutationKey = (userId: string,) => [`/users/${userId}`] as const;

export type UpdateUsersMutationResult = NonNullable<Awaited<ReturnType<typeof updateUsers>>>
export type UpdateUsersMutationError = Promise<unknown>

/**
 * @summary Update a specific users
 */
export const useUpdateUsers = <TError = Promise<unknown>>(
  userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateUsers>>, TError, Key, Users, Awaited<ReturnType<typeof updateUsers>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateUsersMutationKey(userId);
  const swrFn = getUpdateUsersMutationFetcher(userId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific users
 */
export type deleteUsersResponse204 = {
  data: void
  status: 204
}
    
export type deleteUsersResponseComposite = deleteUsersResponse204;
    
export type deleteUsersResponse = deleteUsersResponseComposite & {
  headers: Headers;
}

export const getDeleteUsersUrl = (userId: string,) => {


  

  return `/users/${userId}`
}

export const deleteUsers = async (userId: string, options?: RequestInit): Promise<deleteUsersResponse> => {
  
  const res = await fetch(getDeleteUsersUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteUsersResponse
}




export const getDeleteUsersMutationFetcher = (userId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteUsersResponse> => {
    return deleteUsers(userId, options);
  }
}
export const getDeleteUsersMutationKey = (userId: string,) => [`/users/${userId}`] as const;

export type DeleteUsersMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsers>>>
export type DeleteUsersMutationError = Promise<unknown>

/**
 * @summary Delete a specific users
 */
export const useDeleteUsers = <TError = Promise<unknown>>(
  userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteUsers>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteUsers>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteUsersMutationKey(userId);
  const swrFn = getDeleteUsersMutationFetcher(userId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of friend_requests
 */
export type getFriendRequestsResponse200 = {
  data: FriendRequests[]
  status: 200
}
    
export type getFriendRequestsResponseComposite = getFriendRequestsResponse200;
    
export type getFriendRequestsResponse = getFriendRequestsResponseComposite & {
  headers: Headers;
}

export const getGetFriendRequestsUrl = () => {


  

  return `/friend_requests`
}

export const getFriendRequests = async ( options?: RequestInit): Promise<getFriendRequestsResponse> => {
  
  const res = await fetch(getGetFriendRequestsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getFriendRequestsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getFriendRequestsResponse
}




export const getGetFriendRequestsKey = () => [`/friend_requests`] as const;

export type GetFriendRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof getFriendRequests>>>
export type GetFriendRequestsQueryError = Promise<unknown>

/**
 * @summary Get list of friend_requests
 */
export const useGetFriendRequests = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getFriendRequests>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetFriendRequestsKey() : null);
  const swrFn = () => getFriendRequests(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new friend_requests
 */
export type createFriendRequestsResponse201 = {
  data: void
  status: 201
}
    
export type createFriendRequestsResponseComposite = createFriendRequestsResponse201;
    
export type createFriendRequestsResponse = createFriendRequestsResponseComposite & {
  headers: Headers;
}

export const getCreateFriendRequestsUrl = () => {


  

  return `/friend_requests`
}

export const createFriendRequests = async (friendRequests: FriendRequests, options?: RequestInit): Promise<createFriendRequestsResponse> => {
  
  const res = await fetch(getCreateFriendRequestsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      friendRequests,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createFriendRequestsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createFriendRequestsResponse
}




export const getCreateFriendRequestsMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: FriendRequests }): Promise<createFriendRequestsResponse> => {
    return createFriendRequests(arg, options);
  }
}
export const getCreateFriendRequestsMutationKey = () => [`/friend_requests`] as const;

export type CreateFriendRequestsMutationResult = NonNullable<Awaited<ReturnType<typeof createFriendRequests>>>
export type CreateFriendRequestsMutationError = Promise<unknown>

/**
 * @summary Create a new friend_requests
 */
export const useCreateFriendRequests = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createFriendRequests>>, TError, Key, FriendRequests, Awaited<ReturnType<typeof createFriendRequests>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateFriendRequestsMutationKey();
  const swrFn = getCreateFriendRequestsMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific friend_requests
 */
export type getFriendRequestsByIdResponse200 = {
  data: FriendRequests
  status: 200
}
    
export type getFriendRequestsByIdResponseComposite = getFriendRequestsByIdResponse200;
    
export type getFriendRequestsByIdResponse = getFriendRequestsByIdResponseComposite & {
  headers: Headers;
}

export const getGetFriendRequestsByIdUrl = (friendRequestId: string,) => {


  

  return `/friend_requests/${friendRequestId}`
}

export const getFriendRequestsById = async (friendRequestId: string, options?: RequestInit): Promise<getFriendRequestsByIdResponse> => {
  
  const res = await fetch(getGetFriendRequestsByIdUrl(friendRequestId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getFriendRequestsByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getFriendRequestsByIdResponse
}




export const getGetFriendRequestsByIdKey = (friendRequestId: string,) => [`/friend_requests/${friendRequestId}`] as const;

export type GetFriendRequestsByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getFriendRequestsById>>>
export type GetFriendRequestsByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific friend_requests
 */
export const useGetFriendRequestsById = <TError = Promise<unknown>>(
  friendRequestId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getFriendRequestsById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(friendRequestId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetFriendRequestsByIdKey(friendRequestId) : null);
  const swrFn = () => getFriendRequestsById(friendRequestId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific friend_requests
 */
export type updateFriendRequestsResponse200 = {
  data: void
  status: 200
}
    
export type updateFriendRequestsResponseComposite = updateFriendRequestsResponse200;
    
export type updateFriendRequestsResponse = updateFriendRequestsResponseComposite & {
  headers: Headers;
}

export const getUpdateFriendRequestsUrl = (friendRequestId: string,) => {


  

  return `/friend_requests/${friendRequestId}`
}

export const updateFriendRequests = async (friendRequestId: string,
    friendRequests: FriendRequests, options?: RequestInit): Promise<updateFriendRequestsResponse> => {
  
  const res = await fetch(getUpdateFriendRequestsUrl(friendRequestId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      friendRequests,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateFriendRequestsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateFriendRequestsResponse
}




export const getUpdateFriendRequestsMutationFetcher = (friendRequestId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: FriendRequests }): Promise<updateFriendRequestsResponse> => {
    return updateFriendRequests(friendRequestId, arg, options);
  }
}
export const getUpdateFriendRequestsMutationKey = (friendRequestId: string,) => [`/friend_requests/${friendRequestId}`] as const;

export type UpdateFriendRequestsMutationResult = NonNullable<Awaited<ReturnType<typeof updateFriendRequests>>>
export type UpdateFriendRequestsMutationError = Promise<unknown>

/**
 * @summary Update a specific friend_requests
 */
export const useUpdateFriendRequests = <TError = Promise<unknown>>(
  friendRequestId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateFriendRequests>>, TError, Key, FriendRequests, Awaited<ReturnType<typeof updateFriendRequests>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateFriendRequestsMutationKey(friendRequestId);
  const swrFn = getUpdateFriendRequestsMutationFetcher(friendRequestId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific friend_requests
 */
export type deleteFriendRequestsResponse204 = {
  data: void
  status: 204
}
    
export type deleteFriendRequestsResponseComposite = deleteFriendRequestsResponse204;
    
export type deleteFriendRequestsResponse = deleteFriendRequestsResponseComposite & {
  headers: Headers;
}

export const getDeleteFriendRequestsUrl = (friendRequestId: string,) => {


  

  return `/friend_requests/${friendRequestId}`
}

export const deleteFriendRequests = async (friendRequestId: string, options?: RequestInit): Promise<deleteFriendRequestsResponse> => {
  
  const res = await fetch(getDeleteFriendRequestsUrl(friendRequestId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteFriendRequestsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteFriendRequestsResponse
}




export const getDeleteFriendRequestsMutationFetcher = (friendRequestId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteFriendRequestsResponse> => {
    return deleteFriendRequests(friendRequestId, options);
  }
}
export const getDeleteFriendRequestsMutationKey = (friendRequestId: string,) => [`/friend_requests/${friendRequestId}`] as const;

export type DeleteFriendRequestsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFriendRequests>>>
export type DeleteFriendRequestsMutationError = Promise<unknown>

/**
 * @summary Delete a specific friend_requests
 */
export const useDeleteFriendRequests = <TError = Promise<unknown>>(
  friendRequestId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteFriendRequests>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteFriendRequests>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteFriendRequestsMutationKey(friendRequestId);
  const swrFn = getDeleteFriendRequestsMutationFetcher(friendRequestId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of friends
 */
export type getFriendsResponse200 = {
  data: Friends[]
  status: 200
}
    
export type getFriendsResponseComposite = getFriendsResponse200;
    
export type getFriendsResponse = getFriendsResponseComposite & {
  headers: Headers;
}

export const getGetFriendsUrl = () => {


  

  return `/friends`
}

export const getFriends = async ( options?: RequestInit): Promise<getFriendsResponse> => {
  
  const res = await fetch(getGetFriendsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getFriendsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getFriendsResponse
}




export const getGetFriendsKey = () => [`/friends`] as const;

export type GetFriendsQueryResult = NonNullable<Awaited<ReturnType<typeof getFriends>>>
export type GetFriendsQueryError = Promise<unknown>

/**
 * @summary Get list of friends
 */
export const useGetFriends = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getFriends>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetFriendsKey() : null);
  const swrFn = () => getFriends(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new friends
 */
export type createFriendsResponse201 = {
  data: void
  status: 201
}
    
export type createFriendsResponseComposite = createFriendsResponse201;
    
export type createFriendsResponse = createFriendsResponseComposite & {
  headers: Headers;
}

export const getCreateFriendsUrl = () => {


  

  return `/friends`
}

export const createFriends = async (friends: Friends, options?: RequestInit): Promise<createFriendsResponse> => {
  
  const res = await fetch(getCreateFriendsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      friends,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createFriendsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createFriendsResponse
}




export const getCreateFriendsMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Friends }): Promise<createFriendsResponse> => {
    return createFriends(arg, options);
  }
}
export const getCreateFriendsMutationKey = () => [`/friends`] as const;

export type CreateFriendsMutationResult = NonNullable<Awaited<ReturnType<typeof createFriends>>>
export type CreateFriendsMutationError = Promise<unknown>

/**
 * @summary Create a new friends
 */
export const useCreateFriends = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createFriends>>, TError, Key, Friends, Awaited<ReturnType<typeof createFriends>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateFriendsMutationKey();
  const swrFn = getCreateFriendsMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific friends
 */
export type getFriendsByIdResponse200 = {
  data: Friends
  status: 200
}
    
export type getFriendsByIdResponseComposite = getFriendsByIdResponse200;
    
export type getFriendsByIdResponse = getFriendsByIdResponseComposite & {
  headers: Headers;
}

export const getGetFriendsByIdUrl = (userId1: string,
    userId2: string,) => {


  

  return `/friends/${userId1}/${userId2}`
}

export const getFriendsById = async (userId1: string,
    userId2: string, options?: RequestInit): Promise<getFriendsByIdResponse> => {
  
  const res = await fetch(getGetFriendsByIdUrl(userId1,userId2),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getFriendsByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getFriendsByIdResponse
}




export const getGetFriendsByIdKey = (userId1: string,
    userId2: string,) => [`/friends/${userId1}/${userId2}`] as const;

export type GetFriendsByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getFriendsById>>>
export type GetFriendsByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific friends
 */
export const useGetFriendsById = <TError = Promise<unknown>>(
  userId1: string,
    userId2: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getFriendsById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(userId1 && userId2)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetFriendsByIdKey(userId1,userId2) : null);
  const swrFn = () => getFriendsById(userId1,userId2, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific friends
 */
export type updateFriendsResponse200 = {
  data: void
  status: 200
}
    
export type updateFriendsResponseComposite = updateFriendsResponse200;
    
export type updateFriendsResponse = updateFriendsResponseComposite & {
  headers: Headers;
}

export const getUpdateFriendsUrl = (userId1: string,
    userId2: string,) => {


  

  return `/friends/${userId1}/${userId2}`
}

export const updateFriends = async (userId1: string,
    userId2: string,
    friends: Friends, options?: RequestInit): Promise<updateFriendsResponse> => {
  
  const res = await fetch(getUpdateFriendsUrl(userId1,userId2),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      friends,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateFriendsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateFriendsResponse
}




export const getUpdateFriendsMutationFetcher = (userId1: string,
    userId2: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Friends }): Promise<updateFriendsResponse> => {
    return updateFriends(userId1, userId2, arg, options);
  }
}
export const getUpdateFriendsMutationKey = (userId1: string,
    userId2: string,) => [`/friends/${userId1}/${userId2}`] as const;

export type UpdateFriendsMutationResult = NonNullable<Awaited<ReturnType<typeof updateFriends>>>
export type UpdateFriendsMutationError = Promise<unknown>

/**
 * @summary Update a specific friends
 */
export const useUpdateFriends = <TError = Promise<unknown>>(
  userId1: string,
    userId2: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateFriends>>, TError, Key, Friends, Awaited<ReturnType<typeof updateFriends>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateFriendsMutationKey(userId1,userId2);
  const swrFn = getUpdateFriendsMutationFetcher(userId1,userId2, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific friends
 */
export type deleteFriendsResponse204 = {
  data: void
  status: 204
}
    
export type deleteFriendsResponseComposite = deleteFriendsResponse204;
    
export type deleteFriendsResponse = deleteFriendsResponseComposite & {
  headers: Headers;
}

export const getDeleteFriendsUrl = (userId1: string,
    userId2: string,) => {


  

  return `/friends/${userId1}/${userId2}`
}

export const deleteFriends = async (userId1: string,
    userId2: string, options?: RequestInit): Promise<deleteFriendsResponse> => {
  
  const res = await fetch(getDeleteFriendsUrl(userId1,userId2),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteFriendsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteFriendsResponse
}




export const getDeleteFriendsMutationFetcher = (userId1: string,
    userId2: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteFriendsResponse> => {
    return deleteFriends(userId1, userId2, options);
  }
}
export const getDeleteFriendsMutationKey = (userId1: string,
    userId2: string,) => [`/friends/${userId1}/${userId2}`] as const;

export type DeleteFriendsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteFriends>>>
export type DeleteFriendsMutationError = Promise<unknown>

/**
 * @summary Delete a specific friends
 */
export const useDeleteFriends = <TError = Promise<unknown>>(
  userId1: string,
    userId2: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteFriends>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteFriends>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteFriendsMutationKey(userId1,userId2);
  const swrFn = getDeleteFriendsMutationFetcher(userId1,userId2, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of games
 */
export type getGamesResponse200 = {
  data: Games[]
  status: 200
}
    
export type getGamesResponseComposite = getGamesResponse200;
    
export type getGamesResponse = getGamesResponseComposite & {
  headers: Headers;
}

export const getGetGamesUrl = () => {


  

  return `/games`
}

export const getGames = async ( options?: RequestInit): Promise<getGamesResponse> => {
  
  const res = await fetch(getGetGamesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getGamesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getGamesResponse
}




export const getGetGamesKey = () => [`/games`] as const;

export type GetGamesQueryResult = NonNullable<Awaited<ReturnType<typeof getGames>>>
export type GetGamesQueryError = Promise<unknown>

/**
 * @summary Get list of games
 */
export const useGetGames = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getGames>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetGamesKey() : null);
  const swrFn = () => getGames(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new games
 */
export type createGamesResponse201 = {
  data: void
  status: 201
}
    
export type createGamesResponseComposite = createGamesResponse201;
    
export type createGamesResponse = createGamesResponseComposite & {
  headers: Headers;
}

export const getCreateGamesUrl = () => {


  

  return `/games`
}

export const createGames = async (games: Games, options?: RequestInit): Promise<createGamesResponse> => {
  
  const res = await fetch(getCreateGamesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      games,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createGamesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createGamesResponse
}




export const getCreateGamesMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Games }): Promise<createGamesResponse> => {
    return createGames(arg, options);
  }
}
export const getCreateGamesMutationKey = () => [`/games`] as const;

export type CreateGamesMutationResult = NonNullable<Awaited<ReturnType<typeof createGames>>>
export type CreateGamesMutationError = Promise<unknown>

/**
 * @summary Create a new games
 */
export const useCreateGames = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createGames>>, TError, Key, Games, Awaited<ReturnType<typeof createGames>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateGamesMutationKey();
  const swrFn = getCreateGamesMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific games
 */
export type getGamesByIdResponse200 = {
  data: Games
  status: 200
}
    
export type getGamesByIdResponseComposite = getGamesByIdResponse200;
    
export type getGamesByIdResponse = getGamesByIdResponseComposite & {
  headers: Headers;
}

export const getGetGamesByIdUrl = (gameId: string,) => {


  

  return `/games/${gameId}`
}

export const getGamesById = async (gameId: string, options?: RequestInit): Promise<getGamesByIdResponse> => {
  
  const res = await fetch(getGetGamesByIdUrl(gameId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getGamesByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getGamesByIdResponse
}




export const getGetGamesByIdKey = (gameId: string,) => [`/games/${gameId}`] as const;

export type GetGamesByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getGamesById>>>
export type GetGamesByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific games
 */
export const useGetGamesById = <TError = Promise<unknown>>(
  gameId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getGamesById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(gameId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetGamesByIdKey(gameId) : null);
  const swrFn = () => getGamesById(gameId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific games
 */
export type updateGamesResponse200 = {
  data: void
  status: 200
}
    
export type updateGamesResponseComposite = updateGamesResponse200;
    
export type updateGamesResponse = updateGamesResponseComposite & {
  headers: Headers;
}

export const getUpdateGamesUrl = (gameId: string,) => {


  

  return `/games/${gameId}`
}

export const updateGames = async (gameId: string,
    games: Games, options?: RequestInit): Promise<updateGamesResponse> => {
  
  const res = await fetch(getUpdateGamesUrl(gameId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      games,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateGamesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateGamesResponse
}




export const getUpdateGamesMutationFetcher = (gameId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Games }): Promise<updateGamesResponse> => {
    return updateGames(gameId, arg, options);
  }
}
export const getUpdateGamesMutationKey = (gameId: string,) => [`/games/${gameId}`] as const;

export type UpdateGamesMutationResult = NonNullable<Awaited<ReturnType<typeof updateGames>>>
export type UpdateGamesMutationError = Promise<unknown>

/**
 * @summary Update a specific games
 */
export const useUpdateGames = <TError = Promise<unknown>>(
  gameId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateGames>>, TError, Key, Games, Awaited<ReturnType<typeof updateGames>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateGamesMutationKey(gameId);
  const swrFn = getUpdateGamesMutationFetcher(gameId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific games
 */
export type deleteGamesResponse204 = {
  data: void
  status: 204
}
    
export type deleteGamesResponseComposite = deleteGamesResponse204;
    
export type deleteGamesResponse = deleteGamesResponseComposite & {
  headers: Headers;
}

export const getDeleteGamesUrl = (gameId: string,) => {


  

  return `/games/${gameId}`
}

export const deleteGames = async (gameId: string, options?: RequestInit): Promise<deleteGamesResponse> => {
  
  const res = await fetch(getDeleteGamesUrl(gameId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteGamesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteGamesResponse
}




export const getDeleteGamesMutationFetcher = (gameId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteGamesResponse> => {
    return deleteGames(gameId, options);
  }
}
export const getDeleteGamesMutationKey = (gameId: string,) => [`/games/${gameId}`] as const;

export type DeleteGamesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGames>>>
export type DeleteGamesMutationError = Promise<unknown>

/**
 * @summary Delete a specific games
 */
export const useDeleteGames = <TError = Promise<unknown>>(
  gameId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteGames>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteGames>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteGamesMutationKey(gameId);
  const swrFn = getDeleteGamesMutationFetcher(gameId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of sessions
 */
export type getSessionsResponse200 = {
  data: Sessions[]
  status: 200
}
    
export type getSessionsResponseComposite = getSessionsResponse200;
    
export type getSessionsResponse = getSessionsResponseComposite & {
  headers: Headers;
}

export const getGetSessionsUrl = () => {


  

  return `/sessions`
}

export const getSessions = async ( options?: RequestInit): Promise<getSessionsResponse> => {
  
  const res = await fetch(getGetSessionsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSessionsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getSessionsResponse
}




export const getGetSessionsKey = () => [`/sessions`] as const;

export type GetSessionsQueryResult = NonNullable<Awaited<ReturnType<typeof getSessions>>>
export type GetSessionsQueryError = Promise<unknown>

/**
 * @summary Get list of sessions
 */
export const useGetSessions = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSessions>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSessionsKey() : null);
  const swrFn = () => getSessions(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new sessions
 */
export type createSessionsResponse201 = {
  data: void
  status: 201
}
    
export type createSessionsResponseComposite = createSessionsResponse201;
    
export type createSessionsResponse = createSessionsResponseComposite & {
  headers: Headers;
}

export const getCreateSessionsUrl = () => {


  

  return `/sessions`
}

export const createSessions = async (sessions: Sessions, options?: RequestInit): Promise<createSessionsResponse> => {
  
  const res = await fetch(getCreateSessionsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sessions,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createSessionsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createSessionsResponse
}




export const getCreateSessionsMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Sessions }): Promise<createSessionsResponse> => {
    return createSessions(arg, options);
  }
}
export const getCreateSessionsMutationKey = () => [`/sessions`] as const;

export type CreateSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof createSessions>>>
export type CreateSessionsMutationError = Promise<unknown>

/**
 * @summary Create a new sessions
 */
export const useCreateSessions = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createSessions>>, TError, Key, Sessions, Awaited<ReturnType<typeof createSessions>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateSessionsMutationKey();
  const swrFn = getCreateSessionsMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific sessions
 */
export type getSessionsByIdResponse200 = {
  data: Sessions
  status: 200
}
    
export type getSessionsByIdResponseComposite = getSessionsByIdResponse200;
    
export type getSessionsByIdResponse = getSessionsByIdResponseComposite & {
  headers: Headers;
}

export const getGetSessionsByIdUrl = (sessionId: string,) => {


  

  return `/sessions/${sessionId}`
}

export const getSessionsById = async (sessionId: string, options?: RequestInit): Promise<getSessionsByIdResponse> => {
  
  const res = await fetch(getGetSessionsByIdUrl(sessionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSessionsByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getSessionsByIdResponse
}




export const getGetSessionsByIdKey = (sessionId: string,) => [`/sessions/${sessionId}`] as const;

export type GetSessionsByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionsById>>>
export type GetSessionsByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific sessions
 */
export const useGetSessionsById = <TError = Promise<unknown>>(
  sessionId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSessionsById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(sessionId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSessionsByIdKey(sessionId) : null);
  const swrFn = () => getSessionsById(sessionId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific sessions
 */
export type updateSessionsResponse200 = {
  data: void
  status: 200
}
    
export type updateSessionsResponseComposite = updateSessionsResponse200;
    
export type updateSessionsResponse = updateSessionsResponseComposite & {
  headers: Headers;
}

export const getUpdateSessionsUrl = (sessionId: string,) => {


  

  return `/sessions/${sessionId}`
}

export const updateSessions = async (sessionId: string,
    sessions: Sessions, options?: RequestInit): Promise<updateSessionsResponse> => {
  
  const res = await fetch(getUpdateSessionsUrl(sessionId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sessions,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateSessionsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateSessionsResponse
}




export const getUpdateSessionsMutationFetcher = (sessionId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Sessions }): Promise<updateSessionsResponse> => {
    return updateSessions(sessionId, arg, options);
  }
}
export const getUpdateSessionsMutationKey = (sessionId: string,) => [`/sessions/${sessionId}`] as const;

export type UpdateSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof updateSessions>>>
export type UpdateSessionsMutationError = Promise<unknown>

/**
 * @summary Update a specific sessions
 */
export const useUpdateSessions = <TError = Promise<unknown>>(
  sessionId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateSessions>>, TError, Key, Sessions, Awaited<ReturnType<typeof updateSessions>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateSessionsMutationKey(sessionId);
  const swrFn = getUpdateSessionsMutationFetcher(sessionId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific sessions
 */
export type deleteSessionsResponse204 = {
  data: void
  status: 204
}
    
export type deleteSessionsResponseComposite = deleteSessionsResponse204;
    
export type deleteSessionsResponse = deleteSessionsResponseComposite & {
  headers: Headers;
}

export const getDeleteSessionsUrl = (sessionId: string,) => {


  

  return `/sessions/${sessionId}`
}

export const deleteSessions = async (sessionId: string, options?: RequestInit): Promise<deleteSessionsResponse> => {
  
  const res = await fetch(getDeleteSessionsUrl(sessionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteSessionsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteSessionsResponse
}




export const getDeleteSessionsMutationFetcher = (sessionId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteSessionsResponse> => {
    return deleteSessions(sessionId, options);
  }
}
export const getDeleteSessionsMutationKey = (sessionId: string,) => [`/sessions/${sessionId}`] as const;

export type DeleteSessionsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSessions>>>
export type DeleteSessionsMutationError = Promise<unknown>

/**
 * @summary Delete a specific sessions
 */
export const useDeleteSessions = <TError = Promise<unknown>>(
  sessionId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteSessions>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteSessions>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteSessionsMutationKey(sessionId);
  const swrFn = getDeleteSessionsMutationFetcher(sessionId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of session_invites
 */
export type getSessionInvitesResponse200 = {
  data: SessionInvites[]
  status: 200
}
    
export type getSessionInvitesResponseComposite = getSessionInvitesResponse200;
    
export type getSessionInvitesResponse = getSessionInvitesResponseComposite & {
  headers: Headers;
}

export const getGetSessionInvitesUrl = () => {


  

  return `/session_invites`
}

export const getSessionInvites = async ( options?: RequestInit): Promise<getSessionInvitesResponse> => {
  
  const res = await fetch(getGetSessionInvitesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSessionInvitesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getSessionInvitesResponse
}




export const getGetSessionInvitesKey = () => [`/session_invites`] as const;

export type GetSessionInvitesQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionInvites>>>
export type GetSessionInvitesQueryError = Promise<unknown>

/**
 * @summary Get list of session_invites
 */
export const useGetSessionInvites = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSessionInvites>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSessionInvitesKey() : null);
  const swrFn = () => getSessionInvites(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new session_invites
 */
export type createSessionInvitesResponse201 = {
  data: void
  status: 201
}
    
export type createSessionInvitesResponseComposite = createSessionInvitesResponse201;
    
export type createSessionInvitesResponse = createSessionInvitesResponseComposite & {
  headers: Headers;
}

export const getCreateSessionInvitesUrl = () => {


  

  return `/session_invites`
}

export const createSessionInvites = async (sessionInvites: SessionInvites, options?: RequestInit): Promise<createSessionInvitesResponse> => {
  
  const res = await fetch(getCreateSessionInvitesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sessionInvites,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createSessionInvitesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createSessionInvitesResponse
}




export const getCreateSessionInvitesMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: SessionInvites }): Promise<createSessionInvitesResponse> => {
    return createSessionInvites(arg, options);
  }
}
export const getCreateSessionInvitesMutationKey = () => [`/session_invites`] as const;

export type CreateSessionInvitesMutationResult = NonNullable<Awaited<ReturnType<typeof createSessionInvites>>>
export type CreateSessionInvitesMutationError = Promise<unknown>

/**
 * @summary Create a new session_invites
 */
export const useCreateSessionInvites = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createSessionInvites>>, TError, Key, SessionInvites, Awaited<ReturnType<typeof createSessionInvites>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateSessionInvitesMutationKey();
  const swrFn = getCreateSessionInvitesMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific session_invites
 */
export type getSessionInvitesByIdResponse200 = {
  data: SessionInvites
  status: 200
}
    
export type getSessionInvitesByIdResponseComposite = getSessionInvitesByIdResponse200;
    
export type getSessionInvitesByIdResponse = getSessionInvitesByIdResponseComposite & {
  headers: Headers;
}

export const getGetSessionInvitesByIdUrl = (inviteId: string,) => {


  

  return `/session_invites/${inviteId}`
}

export const getSessionInvitesById = async (inviteId: string, options?: RequestInit): Promise<getSessionInvitesByIdResponse> => {
  
  const res = await fetch(getGetSessionInvitesByIdUrl(inviteId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSessionInvitesByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getSessionInvitesByIdResponse
}




export const getGetSessionInvitesByIdKey = (inviteId: string,) => [`/session_invites/${inviteId}`] as const;

export type GetSessionInvitesByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionInvitesById>>>
export type GetSessionInvitesByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific session_invites
 */
export const useGetSessionInvitesById = <TError = Promise<unknown>>(
  inviteId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSessionInvitesById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(inviteId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSessionInvitesByIdKey(inviteId) : null);
  const swrFn = () => getSessionInvitesById(inviteId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific session_invites
 */
export type updateSessionInvitesResponse200 = {
  data: void
  status: 200
}
    
export type updateSessionInvitesResponseComposite = updateSessionInvitesResponse200;
    
export type updateSessionInvitesResponse = updateSessionInvitesResponseComposite & {
  headers: Headers;
}

export const getUpdateSessionInvitesUrl = (inviteId: string,) => {


  

  return `/session_invites/${inviteId}`
}

export const updateSessionInvites = async (inviteId: string,
    sessionInvites: SessionInvites, options?: RequestInit): Promise<updateSessionInvitesResponse> => {
  
  const res = await fetch(getUpdateSessionInvitesUrl(inviteId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sessionInvites,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateSessionInvitesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateSessionInvitesResponse
}




export const getUpdateSessionInvitesMutationFetcher = (inviteId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: SessionInvites }): Promise<updateSessionInvitesResponse> => {
    return updateSessionInvites(inviteId, arg, options);
  }
}
export const getUpdateSessionInvitesMutationKey = (inviteId: string,) => [`/session_invites/${inviteId}`] as const;

export type UpdateSessionInvitesMutationResult = NonNullable<Awaited<ReturnType<typeof updateSessionInvites>>>
export type UpdateSessionInvitesMutationError = Promise<unknown>

/**
 * @summary Update a specific session_invites
 */
export const useUpdateSessionInvites = <TError = Promise<unknown>>(
  inviteId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateSessionInvites>>, TError, Key, SessionInvites, Awaited<ReturnType<typeof updateSessionInvites>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateSessionInvitesMutationKey(inviteId);
  const swrFn = getUpdateSessionInvitesMutationFetcher(inviteId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific session_invites
 */
export type deleteSessionInvitesResponse204 = {
  data: void
  status: 204
}
    
export type deleteSessionInvitesResponseComposite = deleteSessionInvitesResponse204;
    
export type deleteSessionInvitesResponse = deleteSessionInvitesResponseComposite & {
  headers: Headers;
}

export const getDeleteSessionInvitesUrl = (inviteId: string,) => {


  

  return `/session_invites/${inviteId}`
}

export const deleteSessionInvites = async (inviteId: string, options?: RequestInit): Promise<deleteSessionInvitesResponse> => {
  
  const res = await fetch(getDeleteSessionInvitesUrl(inviteId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteSessionInvitesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteSessionInvitesResponse
}




export const getDeleteSessionInvitesMutationFetcher = (inviteId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteSessionInvitesResponse> => {
    return deleteSessionInvites(inviteId, options);
  }
}
export const getDeleteSessionInvitesMutationKey = (inviteId: string,) => [`/session_invites/${inviteId}`] as const;

export type DeleteSessionInvitesMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSessionInvites>>>
export type DeleteSessionInvitesMutationError = Promise<unknown>

/**
 * @summary Delete a specific session_invites
 */
export const useDeleteSessionInvites = <TError = Promise<unknown>>(
  inviteId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteSessionInvites>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteSessionInvites>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteSessionInvitesMutationKey(inviteId);
  const swrFn = getDeleteSessionInvitesMutationFetcher(inviteId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of session_players
 */
export type getSessionPlayersResponse200 = {
  data: SessionPlayers[]
  status: 200
}
    
export type getSessionPlayersResponseComposite = getSessionPlayersResponse200;
    
export type getSessionPlayersResponse = getSessionPlayersResponseComposite & {
  headers: Headers;
}

export const getGetSessionPlayersUrl = () => {


  

  return `/session_players`
}

export const getSessionPlayers = async ( options?: RequestInit): Promise<getSessionPlayersResponse> => {
  
  const res = await fetch(getGetSessionPlayersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSessionPlayersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getSessionPlayersResponse
}




export const getGetSessionPlayersKey = () => [`/session_players`] as const;

export type GetSessionPlayersQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionPlayers>>>
export type GetSessionPlayersQueryError = Promise<unknown>

/**
 * @summary Get list of session_players
 */
export const useGetSessionPlayers = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSessionPlayers>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSessionPlayersKey() : null);
  const swrFn = () => getSessionPlayers(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new session_players
 */
export type createSessionPlayersResponse201 = {
  data: void
  status: 201
}
    
export type createSessionPlayersResponseComposite = createSessionPlayersResponse201;
    
export type createSessionPlayersResponse = createSessionPlayersResponseComposite & {
  headers: Headers;
}

export const getCreateSessionPlayersUrl = () => {


  

  return `/session_players`
}

export const createSessionPlayers = async (sessionPlayers: SessionPlayers, options?: RequestInit): Promise<createSessionPlayersResponse> => {
  
  const res = await fetch(getCreateSessionPlayersUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sessionPlayers,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createSessionPlayersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createSessionPlayersResponse
}




export const getCreateSessionPlayersMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: SessionPlayers }): Promise<createSessionPlayersResponse> => {
    return createSessionPlayers(arg, options);
  }
}
export const getCreateSessionPlayersMutationKey = () => [`/session_players`] as const;

export type CreateSessionPlayersMutationResult = NonNullable<Awaited<ReturnType<typeof createSessionPlayers>>>
export type CreateSessionPlayersMutationError = Promise<unknown>

/**
 * @summary Create a new session_players
 */
export const useCreateSessionPlayers = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createSessionPlayers>>, TError, Key, SessionPlayers, Awaited<ReturnType<typeof createSessionPlayers>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateSessionPlayersMutationKey();
  const swrFn = getCreateSessionPlayersMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific session_players
 */
export type getSessionPlayersByIdResponse200 = {
  data: SessionPlayers
  status: 200
}
    
export type getSessionPlayersByIdResponseComposite = getSessionPlayersByIdResponse200;
    
export type getSessionPlayersByIdResponse = getSessionPlayersByIdResponseComposite & {
  headers: Headers;
}

export const getGetSessionPlayersByIdUrl = (sessionId: string,
    userId: string,) => {


  

  return `/session_players/${sessionId}/${userId}`
}

export const getSessionPlayersById = async (sessionId: string,
    userId: string, options?: RequestInit): Promise<getSessionPlayersByIdResponse> => {
  
  const res = await fetch(getGetSessionPlayersByIdUrl(sessionId,userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getSessionPlayersByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getSessionPlayersByIdResponse
}




export const getGetSessionPlayersByIdKey = (sessionId: string,
    userId: string,) => [`/session_players/${sessionId}/${userId}`] as const;

export type GetSessionPlayersByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getSessionPlayersById>>>
export type GetSessionPlayersByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific session_players
 */
export const useGetSessionPlayersById = <TError = Promise<unknown>>(
  sessionId: string,
    userId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getSessionPlayersById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(sessionId && userId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetSessionPlayersByIdKey(sessionId,userId) : null);
  const swrFn = () => getSessionPlayersById(sessionId,userId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific session_players
 */
export type updateSessionPlayersResponse200 = {
  data: void
  status: 200
}
    
export type updateSessionPlayersResponseComposite = updateSessionPlayersResponse200;
    
export type updateSessionPlayersResponse = updateSessionPlayersResponseComposite & {
  headers: Headers;
}

export const getUpdateSessionPlayersUrl = (sessionId: string,
    userId: string,) => {


  

  return `/session_players/${sessionId}/${userId}`
}

export const updateSessionPlayers = async (sessionId: string,
    userId: string,
    sessionPlayers: SessionPlayers, options?: RequestInit): Promise<updateSessionPlayersResponse> => {
  
  const res = await fetch(getUpdateSessionPlayersUrl(sessionId,userId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      sessionPlayers,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateSessionPlayersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateSessionPlayersResponse
}




export const getUpdateSessionPlayersMutationFetcher = (sessionId: string,
    userId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: SessionPlayers }): Promise<updateSessionPlayersResponse> => {
    return updateSessionPlayers(sessionId, userId, arg, options);
  }
}
export const getUpdateSessionPlayersMutationKey = (sessionId: string,
    userId: string,) => [`/session_players/${sessionId}/${userId}`] as const;

export type UpdateSessionPlayersMutationResult = NonNullable<Awaited<ReturnType<typeof updateSessionPlayers>>>
export type UpdateSessionPlayersMutationError = Promise<unknown>

/**
 * @summary Update a specific session_players
 */
export const useUpdateSessionPlayers = <TError = Promise<unknown>>(
  sessionId: string,
    userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateSessionPlayers>>, TError, Key, SessionPlayers, Awaited<ReturnType<typeof updateSessionPlayers>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateSessionPlayersMutationKey(sessionId,userId);
  const swrFn = getUpdateSessionPlayersMutationFetcher(sessionId,userId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific session_players
 */
export type deleteSessionPlayersResponse204 = {
  data: void
  status: 204
}
    
export type deleteSessionPlayersResponseComposite = deleteSessionPlayersResponse204;
    
export type deleteSessionPlayersResponse = deleteSessionPlayersResponseComposite & {
  headers: Headers;
}

export const getDeleteSessionPlayersUrl = (sessionId: string,
    userId: string,) => {


  

  return `/session_players/${sessionId}/${userId}`
}

export const deleteSessionPlayers = async (sessionId: string,
    userId: string, options?: RequestInit): Promise<deleteSessionPlayersResponse> => {
  
  const res = await fetch(getDeleteSessionPlayersUrl(sessionId,userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteSessionPlayersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteSessionPlayersResponse
}




export const getDeleteSessionPlayersMutationFetcher = (sessionId: string,
    userId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteSessionPlayersResponse> => {
    return deleteSessionPlayers(sessionId, userId, options);
  }
}
export const getDeleteSessionPlayersMutationKey = (sessionId: string,
    userId: string,) => [`/session_players/${sessionId}/${userId}`] as const;

export type DeleteSessionPlayersMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSessionPlayers>>>
export type DeleteSessionPlayersMutationError = Promise<unknown>

/**
 * @summary Delete a specific session_players
 */
export const useDeleteSessionPlayers = <TError = Promise<unknown>>(
  sessionId: string,
    userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteSessionPlayers>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteSessionPlayers>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteSessionPlayersMutationKey(sessionId,userId);
  const swrFn = getDeleteSessionPlayersMutationFetcher(sessionId,userId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of game_state
 */
export type getGameStateResponse200 = {
  data: GameState[]
  status: 200
}
    
export type getGameStateResponseComposite = getGameStateResponse200;
    
export type getGameStateResponse = getGameStateResponseComposite & {
  headers: Headers;
}

export const getGetGameStateUrl = () => {


  

  return `/game_state`
}

export const getGameState = async ( options?: RequestInit): Promise<getGameStateResponse> => {
  
  const res = await fetch(getGetGameStateUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getGameStateResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getGameStateResponse
}




export const getGetGameStateKey = () => [`/game_state`] as const;

export type GetGameStateQueryResult = NonNullable<Awaited<ReturnType<typeof getGameState>>>
export type GetGameStateQueryError = Promise<unknown>

/**
 * @summary Get list of game_state
 */
export const useGetGameState = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getGameState>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetGameStateKey() : null);
  const swrFn = () => getGameState(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new game_state
 */
export type createGameStateResponse201 = {
  data: void
  status: 201
}
    
export type createGameStateResponseComposite = createGameStateResponse201;
    
export type createGameStateResponse = createGameStateResponseComposite & {
  headers: Headers;
}

export const getCreateGameStateUrl = () => {


  

  return `/game_state`
}

export const createGameState = async (gameState: GameState, options?: RequestInit): Promise<createGameStateResponse> => {
  
  const res = await fetch(getCreateGameStateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      gameState,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createGameStateResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createGameStateResponse
}




export const getCreateGameStateMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: GameState }): Promise<createGameStateResponse> => {
    return createGameState(arg, options);
  }
}
export const getCreateGameStateMutationKey = () => [`/game_state`] as const;

export type CreateGameStateMutationResult = NonNullable<Awaited<ReturnType<typeof createGameState>>>
export type CreateGameStateMutationError = Promise<unknown>

/**
 * @summary Create a new game_state
 */
export const useCreateGameState = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createGameState>>, TError, Key, GameState, Awaited<ReturnType<typeof createGameState>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateGameStateMutationKey();
  const swrFn = getCreateGameStateMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific game_state
 */
export type getGameStateByIdResponse200 = {
  data: GameState
  status: 200
}
    
export type getGameStateByIdResponseComposite = getGameStateByIdResponse200;
    
export type getGameStateByIdResponse = getGameStateByIdResponseComposite & {
  headers: Headers;
}

export const getGetGameStateByIdUrl = (sessionId: string,) => {


  

  return `/game_state/${sessionId}`
}

export const getGameStateById = async (sessionId: string, options?: RequestInit): Promise<getGameStateByIdResponse> => {
  
  const res = await fetch(getGetGameStateByIdUrl(sessionId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getGameStateByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getGameStateByIdResponse
}




export const getGetGameStateByIdKey = (sessionId: string,) => [`/game_state/${sessionId}`] as const;

export type GetGameStateByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getGameStateById>>>
export type GetGameStateByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific game_state
 */
export const useGetGameStateById = <TError = Promise<unknown>>(
  sessionId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getGameStateById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(sessionId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetGameStateByIdKey(sessionId) : null);
  const swrFn = () => getGameStateById(sessionId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific game_state
 */
export type updateGameStateResponse200 = {
  data: void
  status: 200
}
    
export type updateGameStateResponseComposite = updateGameStateResponse200;
    
export type updateGameStateResponse = updateGameStateResponseComposite & {
  headers: Headers;
}

export const getUpdateGameStateUrl = (sessionId: string,) => {


  

  return `/game_state/${sessionId}`
}

export const updateGameState = async (sessionId: string,
    gameState: GameState, options?: RequestInit): Promise<updateGameStateResponse> => {
  
  const res = await fetch(getUpdateGameStateUrl(sessionId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      gameState,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateGameStateResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateGameStateResponse
}




export const getUpdateGameStateMutationFetcher = (sessionId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: GameState }): Promise<updateGameStateResponse> => {
    return updateGameState(sessionId, arg, options);
  }
}
export const getUpdateGameStateMutationKey = (sessionId: string,) => [`/game_state/${sessionId}`] as const;

export type UpdateGameStateMutationResult = NonNullable<Awaited<ReturnType<typeof updateGameState>>>
export type UpdateGameStateMutationError = Promise<unknown>

/**
 * @summary Update a specific game_state
 */
export const useUpdateGameState = <TError = Promise<unknown>>(
  sessionId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateGameState>>, TError, Key, GameState, Awaited<ReturnType<typeof updateGameState>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateGameStateMutationKey(sessionId);
  const swrFn = getUpdateGameStateMutationFetcher(sessionId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific game_state
 */
export type deleteGameStateResponse204 = {
  data: void
  status: 204
}
    
export type deleteGameStateResponseComposite = deleteGameStateResponse204;
    
export type deleteGameStateResponse = deleteGameStateResponseComposite & {
  headers: Headers;
}

export const getDeleteGameStateUrl = (sessionId: string,) => {


  

  return `/game_state/${sessionId}`
}

export const deleteGameState = async (sessionId: string, options?: RequestInit): Promise<deleteGameStateResponse> => {
  
  const res = await fetch(getDeleteGameStateUrl(sessionId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteGameStateResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteGameStateResponse
}




export const getDeleteGameStateMutationFetcher = (sessionId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteGameStateResponse> => {
    return deleteGameState(sessionId, options);
  }
}
export const getDeleteGameStateMutationKey = (sessionId: string,) => [`/game_state/${sessionId}`] as const;

export type DeleteGameStateMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGameState>>>
export type DeleteGameStateMutationError = Promise<unknown>

/**
 * @summary Delete a specific game_state
 */
export const useDeleteGameState = <TError = Promise<unknown>>(
  sessionId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteGameState>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteGameState>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteGameStateMutationKey(sessionId);
  const swrFn = getDeleteGameStateMutationFetcher(sessionId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of game_results
 */
export type getGameResultsResponse200 = {
  data: GameResults[]
  status: 200
}
    
export type getGameResultsResponseComposite = getGameResultsResponse200;
    
export type getGameResultsResponse = getGameResultsResponseComposite & {
  headers: Headers;
}

export const getGetGameResultsUrl = () => {


  

  return `/game_results`
}

export const getGameResults = async ( options?: RequestInit): Promise<getGameResultsResponse> => {
  
  const res = await fetch(getGetGameResultsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getGameResultsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getGameResultsResponse
}




export const getGetGameResultsKey = () => [`/game_results`] as const;

export type GetGameResultsQueryResult = NonNullable<Awaited<ReturnType<typeof getGameResults>>>
export type GetGameResultsQueryError = Promise<unknown>

/**
 * @summary Get list of game_results
 */
export const useGetGameResults = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getGameResults>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetGameResultsKey() : null);
  const swrFn = () => getGameResults(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new game_results
 */
export type createGameResultsResponse201 = {
  data: void
  status: 201
}
    
export type createGameResultsResponseComposite = createGameResultsResponse201;
    
export type createGameResultsResponse = createGameResultsResponseComposite & {
  headers: Headers;
}

export const getCreateGameResultsUrl = () => {


  

  return `/game_results`
}

export const createGameResults = async (gameResults: GameResults, options?: RequestInit): Promise<createGameResultsResponse> => {
  
  const res = await fetch(getCreateGameResultsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      gameResults,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createGameResultsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createGameResultsResponse
}




export const getCreateGameResultsMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: GameResults }): Promise<createGameResultsResponse> => {
    return createGameResults(arg, options);
  }
}
export const getCreateGameResultsMutationKey = () => [`/game_results`] as const;

export type CreateGameResultsMutationResult = NonNullable<Awaited<ReturnType<typeof createGameResults>>>
export type CreateGameResultsMutationError = Promise<unknown>

/**
 * @summary Create a new game_results
 */
export const useCreateGameResults = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createGameResults>>, TError, Key, GameResults, Awaited<ReturnType<typeof createGameResults>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateGameResultsMutationKey();
  const swrFn = getCreateGameResultsMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific game_results
 */
export type getGameResultsByIdResponse200 = {
  data: GameResults
  status: 200
}
    
export type getGameResultsByIdResponseComposite = getGameResultsByIdResponse200;
    
export type getGameResultsByIdResponse = getGameResultsByIdResponseComposite & {
  headers: Headers;
}

export const getGetGameResultsByIdUrl = (resultId: string,) => {


  

  return `/game_results/${resultId}`
}

export const getGameResultsById = async (resultId: string, options?: RequestInit): Promise<getGameResultsByIdResponse> => {
  
  const res = await fetch(getGetGameResultsByIdUrl(resultId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getGameResultsByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getGameResultsByIdResponse
}




export const getGetGameResultsByIdKey = (resultId: string,) => [`/game_results/${resultId}`] as const;

export type GetGameResultsByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getGameResultsById>>>
export type GetGameResultsByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific game_results
 */
export const useGetGameResultsById = <TError = Promise<unknown>>(
  resultId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getGameResultsById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(resultId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetGameResultsByIdKey(resultId) : null);
  const swrFn = () => getGameResultsById(resultId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific game_results
 */
export type updateGameResultsResponse200 = {
  data: void
  status: 200
}
    
export type updateGameResultsResponseComposite = updateGameResultsResponse200;
    
export type updateGameResultsResponse = updateGameResultsResponseComposite & {
  headers: Headers;
}

export const getUpdateGameResultsUrl = (resultId: string,) => {


  

  return `/game_results/${resultId}`
}

export const updateGameResults = async (resultId: string,
    gameResults: GameResults, options?: RequestInit): Promise<updateGameResultsResponse> => {
  
  const res = await fetch(getUpdateGameResultsUrl(resultId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      gameResults,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateGameResultsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateGameResultsResponse
}




export const getUpdateGameResultsMutationFetcher = (resultId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: GameResults }): Promise<updateGameResultsResponse> => {
    return updateGameResults(resultId, arg, options);
  }
}
export const getUpdateGameResultsMutationKey = (resultId: string,) => [`/game_results/${resultId}`] as const;

export type UpdateGameResultsMutationResult = NonNullable<Awaited<ReturnType<typeof updateGameResults>>>
export type UpdateGameResultsMutationError = Promise<unknown>

/**
 * @summary Update a specific game_results
 */
export const useUpdateGameResults = <TError = Promise<unknown>>(
  resultId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateGameResults>>, TError, Key, GameResults, Awaited<ReturnType<typeof updateGameResults>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateGameResultsMutationKey(resultId);
  const swrFn = getUpdateGameResultsMutationFetcher(resultId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific game_results
 */
export type deleteGameResultsResponse204 = {
  data: void
  status: 204
}
    
export type deleteGameResultsResponseComposite = deleteGameResultsResponse204;
    
export type deleteGameResultsResponse = deleteGameResultsResponseComposite & {
  headers: Headers;
}

export const getDeleteGameResultsUrl = (resultId: string,) => {


  

  return `/game_results/${resultId}`
}

export const deleteGameResults = async (resultId: string, options?: RequestInit): Promise<deleteGameResultsResponse> => {
  
  const res = await fetch(getDeleteGameResultsUrl(resultId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteGameResultsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteGameResultsResponse
}




export const getDeleteGameResultsMutationFetcher = (resultId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteGameResultsResponse> => {
    return deleteGameResults(resultId, options);
  }
}
export const getDeleteGameResultsMutationKey = (resultId: string,) => [`/game_results/${resultId}`] as const;

export type DeleteGameResultsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteGameResults>>>
export type DeleteGameResultsMutationError = Promise<unknown>

/**
 * @summary Delete a specific game_results
 */
export const useDeleteGameResults = <TError = Promise<unknown>>(
  resultId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteGameResults>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteGameResults>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteGameResultsMutationKey(resultId);
  const swrFn = getDeleteGameResultsMutationFetcher(resultId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get list of leaderboards
 */
export type getLeaderboardsResponse200 = {
  data: Leaderboards[]
  status: 200
}
    
export type getLeaderboardsResponseComposite = getLeaderboardsResponse200;
    
export type getLeaderboardsResponse = getLeaderboardsResponseComposite & {
  headers: Headers;
}

export const getGetLeaderboardsUrl = () => {


  

  return `/leaderboards`
}

export const getLeaderboards = async ( options?: RequestInit): Promise<getLeaderboardsResponse> => {
  
  const res = await fetch(getGetLeaderboardsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getLeaderboardsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getLeaderboardsResponse
}




export const getGetLeaderboardsKey = () => [`/leaderboards`] as const;

export type GetLeaderboardsQueryResult = NonNullable<Awaited<ReturnType<typeof getLeaderboards>>>
export type GetLeaderboardsQueryError = Promise<unknown>

/**
 * @summary Get list of leaderboards
 */
export const useGetLeaderboards = <TError = Promise<unknown>>(
   options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getLeaderboards>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetLeaderboardsKey() : null);
  const swrFn = () => getLeaderboards(fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Create a new leaderboards
 */
export type createLeaderboardsResponse201 = {
  data: void
  status: 201
}
    
export type createLeaderboardsResponseComposite = createLeaderboardsResponse201;
    
export type createLeaderboardsResponse = createLeaderboardsResponseComposite & {
  headers: Headers;
}

export const getCreateLeaderboardsUrl = () => {


  

  return `/leaderboards`
}

export const createLeaderboards = async (leaderboards: Leaderboards, options?: RequestInit): Promise<createLeaderboardsResponse> => {
  
  const res = await fetch(getCreateLeaderboardsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      leaderboards,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createLeaderboardsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createLeaderboardsResponse
}




export const getCreateLeaderboardsMutationFetcher = ( options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Leaderboards }): Promise<createLeaderboardsResponse> => {
    return createLeaderboards(arg, options);
  }
}
export const getCreateLeaderboardsMutationKey = () => [`/leaderboards`] as const;

export type CreateLeaderboardsMutationResult = NonNullable<Awaited<ReturnType<typeof createLeaderboards>>>
export type CreateLeaderboardsMutationError = Promise<unknown>

/**
 * @summary Create a new leaderboards
 */
export const useCreateLeaderboards = <TError = Promise<unknown>>(
   options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof createLeaderboards>>, TError, Key, Leaderboards, Awaited<ReturnType<typeof createLeaderboards>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getCreateLeaderboardsMutationKey();
  const swrFn = getCreateLeaderboardsMutationFetcher(fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Get a specific leaderboards
 */
export type getLeaderboardsByIdResponse200 = {
  data: Leaderboards
  status: 200
}
    
export type getLeaderboardsByIdResponseComposite = getLeaderboardsByIdResponse200;
    
export type getLeaderboardsByIdResponse = getLeaderboardsByIdResponseComposite & {
  headers: Headers;
}

export const getGetLeaderboardsByIdUrl = (gameId: string,
    userId: string,) => {


  

  return `/leaderboards/${gameId}/${userId}`
}

export const getLeaderboardsById = async (gameId: string,
    userId: string, options?: RequestInit): Promise<getLeaderboardsByIdResponse> => {
  
  const res = await fetch(getGetLeaderboardsByIdUrl(gameId,userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getLeaderboardsByIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getLeaderboardsByIdResponse
}




export const getGetLeaderboardsByIdKey = (gameId: string,
    userId: string,) => [`/leaderboards/${gameId}/${userId}`] as const;

export type GetLeaderboardsByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getLeaderboardsById>>>
export type GetLeaderboardsByIdQueryError = Promise<unknown>

/**
 * @summary Get a specific leaderboards
 */
export const useGetLeaderboardsById = <TError = Promise<unknown>>(
  gameId: string,
    userId: string, options?: { swr?:SWRConfiguration<Awaited<ReturnType<typeof getLeaderboardsById>>, TError> & { swrKey?: Key, enabled?: boolean }, fetch?: RequestInit }
) => {
  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const isEnabled = swrOptions?.enabled !== false && !!(gameId && userId)
  const swrKey = swrOptions?.swrKey ?? (() => isEnabled ? getGetLeaderboardsByIdKey(gameId,userId) : null);
  const swrFn = () => getLeaderboardsById(gameId,userId, fetchOptions)

  const query = useSwr<Awaited<ReturnType<typeof swrFn>>, TError>(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Update a specific leaderboards
 */
export type updateLeaderboardsResponse200 = {
  data: void
  status: 200
}
    
export type updateLeaderboardsResponseComposite = updateLeaderboardsResponse200;
    
export type updateLeaderboardsResponse = updateLeaderboardsResponseComposite & {
  headers: Headers;
}

export const getUpdateLeaderboardsUrl = (gameId: string,
    userId: string,) => {


  

  return `/leaderboards/${gameId}/${userId}`
}

export const updateLeaderboards = async (gameId: string,
    userId: string,
    leaderboards: Leaderboards, options?: RequestInit): Promise<updateLeaderboardsResponse> => {
  
  const res = await fetch(getUpdateLeaderboardsUrl(gameId,userId),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      leaderboards,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: updateLeaderboardsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as updateLeaderboardsResponse
}




export const getUpdateLeaderboardsMutationFetcher = (gameId: string,
    userId: string, options?: RequestInit) => {
  return (_: Key, { arg }: { arg: Leaderboards }): Promise<updateLeaderboardsResponse> => {
    return updateLeaderboards(gameId, userId, arg, options);
  }
}
export const getUpdateLeaderboardsMutationKey = (gameId: string,
    userId: string,) => [`/leaderboards/${gameId}/${userId}`] as const;

export type UpdateLeaderboardsMutationResult = NonNullable<Awaited<ReturnType<typeof updateLeaderboards>>>
export type UpdateLeaderboardsMutationError = Promise<unknown>

/**
 * @summary Update a specific leaderboards
 */
export const useUpdateLeaderboards = <TError = Promise<unknown>>(
  gameId: string,
    userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof updateLeaderboards>>, TError, Key, Leaderboards, Awaited<ReturnType<typeof updateLeaderboards>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getUpdateLeaderboardsMutationKey(gameId,userId);
  const swrFn = getUpdateLeaderboardsMutationFetcher(gameId,userId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

/**
 * @summary Delete a specific leaderboards
 */
export type deleteLeaderboardsResponse204 = {
  data: void
  status: 204
}
    
export type deleteLeaderboardsResponseComposite = deleteLeaderboardsResponse204;
    
export type deleteLeaderboardsResponse = deleteLeaderboardsResponseComposite & {
  headers: Headers;
}

export const getDeleteLeaderboardsUrl = (gameId: string,
    userId: string,) => {


  

  return `/leaderboards/${gameId}/${userId}`
}

export const deleteLeaderboards = async (gameId: string,
    userId: string, options?: RequestInit): Promise<deleteLeaderboardsResponse> => {
  
  const res = await fetch(getDeleteLeaderboardsUrl(gameId,userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteLeaderboardsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteLeaderboardsResponse
}




export const getDeleteLeaderboardsMutationFetcher = (gameId: string,
    userId: string, options?: RequestInit) => {
  return (_: Key, __: { arg: Arguments }): Promise<deleteLeaderboardsResponse> => {
    return deleteLeaderboards(gameId, userId, options);
  }
}
export const getDeleteLeaderboardsMutationKey = (gameId: string,
    userId: string,) => [`/leaderboards/${gameId}/${userId}`] as const;

export type DeleteLeaderboardsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteLeaderboards>>>
export type DeleteLeaderboardsMutationError = Promise<unknown>

/**
 * @summary Delete a specific leaderboards
 */
export const useDeleteLeaderboards = <TError = Promise<unknown>>(
  gameId: string,
    userId: string, options?: { swr?:SWRMutationConfiguration<Awaited<ReturnType<typeof deleteLeaderboards>>, TError, Key, Arguments, Awaited<ReturnType<typeof deleteLeaderboards>>> & { swrKey?: string }, fetch?: RequestInit}
) => {

  const {swr: swrOptions, fetch: fetchOptions} = options ?? {}

  const swrKey = swrOptions?.swrKey ?? getDeleteLeaderboardsMutationKey(gameId,userId);
  const swrFn = getDeleteLeaderboardsMutationFetcher(gameId,userId, fetchOptions);

  const query = useSWRMutation(swrKey, swrFn, swrOptions)

  return {
    swrKey,
    ...query
  }
}

